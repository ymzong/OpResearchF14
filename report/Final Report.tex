\documentclass{article} % For LaTeX2e
\usepackage{nips13submit_e,times}
%\usepackage{hyperref}
\usepackage[hyphens]{url}
\usepackage{bbm}
\usepackage{amsfonts}
\usepackage{alltt}
\usepackage{multirow, caption}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[noend]{algpseudocode}
\usepackage{etoolbox}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{tgcursor}
\newcommand\userinput[1]{\textbf{#1}}
\newcommand\comment[1]{\textit{#1}}
\newcommand\stdout[1]{\textsl{#1}}

\makeatletter
\preto{\@verbatim}{\topsep=0pt \partopsep=0pt }
\makeatother

% Tweak algorithmic package.
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\title{Freshman Seminar Assignment Problem\\Final Report}

\author{
Keenan Gao \\
\And
Binghui Ouyang \\
\And
Hanwen Zhang \\
\And
Yiming Zong\\ \\
\and Department of Mathematical Sciences \\ Carnegie Mellon University \\ Pittsburgh, PA 15213
}

\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\nipsfinalcopy % Uncomment for camera-ready version

\begin{document}

% Title
\maketitle

% Paper Abstract
\begin{abstract}
    \par\qquad This is the final report for Freshman Seminar Assignment Problem, our team's final project for Operations Research II, Fall 2014. We will first briefly describe the real-world problem and create a basic mathematical model based on the data. Then, we will feed the pre-processed data into several different algorithms with various objective functions and run-time constraints, and compare their final results. Eventually, we will discuss some generalizations of our current problem and propose potential algorithms for solving them.
\end{abstract}

%
% Main Body Starts
%
\section{Problem Overview}
    \texttt{TODO: Overview of the problem in words.}


\section{Mathematical Model}
\par\qquad Based on the problem description in \emph{Section 1}, we can build a mathematical model for it in order to describe an alrogithm for solving the problem with any valid input data.

\subsection{General Input}
\begin{itemize}
    \item $n$: Number of students ($n > 0$);
    \item $m$: Number of seminars ($m > 0$);
    \item $k$: Max number of selections that a student can make ($1 \leq k \leq m$);
    \item $s_{i,j}$: The $j^{\text{th}}$ selection of $i^{\text{th}}$ student, where $1\leq i \leq n$ and $1\leq j \leq k$. $s_{i,j}=0$ when the Student $i$ makes no corresponding choice for Rank $j$;
    \item $q_k$: The quota for $k^{\text{th}}$ seminar, where $1\leq k \leq m$.
\end{itemize}

\subsection{Input Constraints}
\begin{itemize}
    \item Positivity: $n,m,k>0$, $\forall k\in\{1,\cdots,m\}, q_k>0$;
    \item Number of selections for student is bounded by number of available seminars: $k \leq m$;
    \item \textbf{(?)} Student rankings are valid and unique: $\forall (i,j), 1\leq s_{i,j} \leq m$. And, for each $i$, all non-zero entries $s_{i,j}$'s take unique values.
\end{itemize}

\subsection{Decision Variables}
\begin{itemize}
    \item $Y_{i,j}$: Indicator variables for whether Student $i$ is assigned to Seminar $j$, where $1\leq i \leq n$ and $1\leq j \leq k$;
\end{itemize}

\subsection{Data Pre-Processing}
    \par\qquad In order to deal with cases when a student is only willing or allowed to rank $k'<m$ seminars, we automatically set all ``unassigned'' priorities to $(k+1)$. Also, we change the representation of students' preference from \emph{(student, ranking) $\mapsto$ seminar} to \emph{(student, seminar) $\mapsto$ ranking} to make further calculations easier, i.e.
        $$X_{i,j}=\begin{cases}
                    l &\text{If Student $i$ ranked $j$ as $l^{\text{th}}$ option, or $s_{i,l}=j$ for some $l\in\{1,\cdots,k\}$}\\
                    {\bf\it M}     &\text{If Seminar $k$ is not on Student $i$'s list, or $s_{i,l} \neq j$ for all $l\in\{1,\cdots,k\}$}
                  \end{cases},$$
    where ${\bf\it M}$ is an arbitrarily large value in order to discourage the algorithm from assigning a student to a seminar that s/he did not list.

\subsection{General Constraints}
    \begin{itemize}
    \item $Y_{i,j}$'s are indeed indicator variables: $\forall (i,j), Y_{i,j}\in\mathbb{Z}, Y_{i,j}\geq 0, Y_{i,j}\leq 1$;
    \item Each student is assigned precisely one seminar: $\forall i$, $\sum_{l=1}^{m}{Y_{i,l}}=1$;
    \item Each seminar is within enrollment quota: $\forall j$, $\sum_{l=1}^{n}{Y_{l,j}} \leq q_j$;
\end{itemize}

%
% Heuristic Selection
%
\section{Approach for Various Heuristic Functions}
    \par\qquad Due to the flexibility of the original problem, we are proposing different objective functions for optimization, including minimizing the total ``rank'' given by the students, maximizing the number of student getting their top $\lambda k$ choice (where $\lambda\in(0,1)$), etc. In the following sub-sections we present our approach for each heuristic in mathematical terms.

\subsection{Minimize Total Rank of Students}
    \par\qquad In this case, our goal is to minimize the sum of all student rankings for their assigned seminars. To do so, our objective is to minimize $W = \sum_{i=1}^{n}{\sum_{j=1}^{m}{X_{i,j}Y_{i,j}}}.$
\subsection{Minimize Variance of Students Preference in Each Seminar}
    \par\qquad In addition to minimizing total rank of student, it would also be helpful if we could ``balance out'' students' preference of their assignd seminar for each seminar. For example, we do not want to have an assignment where some seminar has all students listing it as their first choice, yet some other seminar has none of the students listing it in their choices at all. With this idea in mind, for each seminar we wish to enforce a hard limit on the number of students enrolled that put it as first tier, second tier, etc.
    \par\qquad Meanwhile, the hard limit can also affect the optimal solution that minimizes total rank of students in the final assignment. Therefore, care needs to be taken while picking the hard limits.
%
% Optimization Algorithms
%
% Exact Algorithm (Hungarian)
%
\section{Exact Algorithm}
    \par\qquad The problem can also be reduced to an \emph{Assignment Problem} when we include ``dummy seminars'' and ``dummy students''. When we apply \emph{Hungarian Algorithm}, we can obtain an absolute optimal solution that minimizes the total ``cost'' of students. Details about the algorithm are as follows:
    
\subsection{Data Pre-Processing}
    \par\qquad We start with the matrix $X_{i,j}$ as obtained in \emph{Section 2.4}. For each column that represents Seminar $j$, we create extra $(j-1)$ dummy seminars by duplicating the same column $q_j$ times. After that, we make our cost matrix square by adding zero rows at the bottom of the cost matrix. This gives us a matrix that we may feed into \emph{Hungarian Algorithm}.

\subsection{Hungarian Algorithm}
    \par\qquad Given the square cost matrix from previous section, we may simply apply \emph{Hungarian Algorithm}, which returns a \emph{student-seminar} assignment with minimal total cost. The algorithm completes in polynomial time \texttt{[reference]}, and given the result we may simply assign each student to the actual seminar that the assignment corresponds to.

%
% Approximation Algorithm (Greedy)
%
\section{Approximation Algorithms}
    \par\qquad While the previous exact algorithm minimizes the sum of ranks of students across all seminars, it does \emph{not} balance out the preference of students in different seminars. In order to do so, a heuristic for approximation is to place an aritificial hard quota, $\mathcal{Q}$, on the number of students in any seminar that places it as its first option. While the optimal solution for different values of $Q$ can be obtained by running Hungarian algorithm with different $\mathcal{Q}$'s by creating different combinations of dummy seminars, its runtime (more than one hour) makes it undesirable.
    \par\qquad In this case, our solution is to use randomized greedy algorithm for arbitrarily number of times, and return the best solution to the user. Following is the detail of the algorithm:

\subsection{Ranking-Based Greedy Algorithm}
    \par For the greedy algorithm, we first satisfy (a portion of) all students' first choices, then second choices, and so on. Depending on the ``popularity'' of each seminar, we may limit the number of students allowed to be added to a seminar at each ranking. The algorithm (as \emph{Algorithm 1} on next page) is outlined as follows, and it can be run multiple times in order to select an assignment with least amount of students that are not assigned to their ranked list.
    \begin{algorithm}
        \caption{Ranking-Based Greedy Algorithm}
        \begin{algorithmic}
            \Ensure{$\text{asgn}_i \gets \text{seminar assignment for Student $i$ based on greedy algorithm}$}
            \For{r = 1 to k}    
                \For{i = 1 to m}
                    \State pool[i] $\gets \{\text{unassigned student s} \mid \text{s listed seminar $i$ as $r^\text{th}$ choice}\}$
                    \State pool[i] $\gets \text{random subset of itself with certain size limit (e.g. seminar quota)}$
                \EndFor
                \State Merge each pool[i] into asgn
            \EndFor
            \State Fill in still unassigned students
        \end{algorithmic}
    \end{algorithm}

\subsection{Stable Assignment Optimization}
    \par Similar to the principle of \emph{Stable Marriage Problem}, in our final seminar assignment we do not want to have two students \emph{A} and \emph{B}, such that \emph{A} prefers \emph{B}'s section, and also vice versa (we call those two students \emph{rogue pair}). This can be done by scanning each pair of students and fixing every \emph{rogue pair}. The algorithm is outlined in \emph{Algorithm 2} on the next page.
    \begin{algorithm}
        \caption{Rogue-Pair Fixing Algorithm}
        \begin{algorithmic}
        \Require $\text{asgn}_i \gets \text{current seminar assignment for Student $i$}$
        \Ensure (i,j) if we found a rogue pair, otherwise null
        \Function{FindRoguePair}{\text{asgn}}
            \For {i=1 to n}
                \For {j=i+1 to n}
                    \If{Student $i$ and $j$ prefer each other's seminar}
                        \Return{(i,j)}
                    \EndIf
                \EndFor
            \EndFor
            \Return{null}
        \EndFunction
        
        \null
        
        \Require $\text{asgn}_i \gets \text{seminar assignment for Student $i$ based on greedy algorithm}$
        \Ensure $\text{asgn}_i$: rogue pair-free assignment for Student $i$
                \State p $\gets$ FindRoguePair(asgn)
                \While {p {\bf not} null}
                    \State (i,j) $\gets$ p
                    \State $\text{asgn}_i \leftrightarrow \text{asgn}_j$
                    \State p $\gets$ FindRoguePair(asgn)
                \EndWhile
        
        \end{algorithmic}
    \end{algorithm}

%
% Summary
%
\section{Summary of Results}
    \par\qquad The algorithms are tested on the real data for the incoming class of Dietrich College for Year 2013 ($n=309$). We have found that the approximation algorithm (...), while the \emph{Hungarian Algorithm} gives really satisfactory assignment within five minutes. Despite the satisfactory performance of the exact algorithm, its run-time complexity $\mathcal{O}(n^3)$ makes the algorithm undesirable for $n>1000$. Following is a comparison between the performance of manual assignment, approximation algorithm, and exact algorithm:

\subsection{Approximation Algorithms}
\subsection{Naive Exact Algorithm}
\subsection{Smoothed Exact Algorithm}

\section{Further Work \& Enhancements}

\subsection{Supporting bi-directional preference/cost parameters with Stable Marriage Algorithm}

\subsection{And more...}

\section{Acknowledgements}
\par\qquad The authors would like to thank Professor Alan Frieze for proposing the Hungarian algorithm in \emph{Section 5} and for holding weekly meetings to track our progress. Also, we thank Professor Brian W. Junker, Professor Joseph E. Devine, and Gloria P. Hill for providing us with the real seminar assignment data for Year 2013. And, the thank goes to Brian Clapper for his Python implementation of Hungarian algorithm, which made our final results and analyis possible.

\urlstyle{rm}
\vskip .2in
\begin{thebibliography}{9}
\bibitem{mt90}
Martello, Silvano, and Paolo Toth. Knapsack Problems: Algorithms and Computer Implementations. Chichester: J. Wiley \& Sons, 1990. Print.
%\url{http://www.or.deis.unibo.it/kp/Chapter7.pdf}
\end{thebibliography}

\end{document}
